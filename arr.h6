# rotate an array left by one
ArrRoL: { .@0_ $@<$ @+ }

# signature:
#   initialValue array function [lfold] output
#
# the accumulate function has to have the signature:
#   accVal arrVal [F] accVal
lfold: { &-v@* {;;} {$.@<$@0 &---v &---v {$}$@+ ! $ &--v lfold! r;; } l?! }

# rev(0 ..< N)
revRange: { . { ; {} } { . 1- revRange! $ 1-_ $ @+ } l?! }

# 0 ..< N
range: { . { ; {} } { . 1- range! $ 1-_ @+ } l?! }

# signature:
#   array function [map] output
#
# the mapping function has to have the signature:
#   value [F] outval
map: { {_@+} @+ {}r lfold! }

# signature:
#   array function [map] output
#
# the mapping function has to have the signature:
#   value [F] outval
flatMap: { {@+} @+ {}r lfold! }

# signature:
#   arr1 arr2 [zip] output
#
# the output array will be: { {A0 B0} {A1 B1} {A2 B2} ... }
zip: { _{}_@+ $ {$! $l$ .@0$@< r _$_$@+_ l$ @+ _$_$@+ } lfold! @<@0 }

# signature:
#   A B [match] output
#
# recursively checks for equality of values
match: { .typeid { = } { .@*r $ .@*r &---v &---v = {;;0} {zip! { !match!* } 1r lfold!} l?! r;; } l?! }

# signature:
#   A [rev] out
rev: { { _$@+ } {}r lfold! }

# signature:
#   Arr Idx [get] out
#
# 0-indexed
get: { range! {;{@<}} flatMap! !@0 }
